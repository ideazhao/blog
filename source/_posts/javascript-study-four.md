title: 征服javascript学习笔记（四）——变量、作用域和内存         
date: 2016-03-27
tags: [javascript]
categories: [JavaScript]
toc: true
---

js里的变量和其他语言不同，它是松散型的，这决定了它只是在特定时间保存特定值的一个名字而已，由于不存在数据类型和值之间的绑定，所以，变量的值和类型都可以在脚本的生命周期内改变。

## 基本类型和引用类型的值

ES变量可能包含两种类型的值：基本类型和引用类型。

**基本类型值**指的是简单的数据段

**引用类型值**指的可能是多个值构成的对象

在将一个值赋给变量时，解析器必须确定这个值是基本类型值还是引用类型值，前面我们讨论过的基本类型值，引用类型的值是保存在内存中的对象，与其他语言不同，js不允许直接访问内存中的位置，也就是不能直接操作对象的内存空间，在操作对象时，实际上是在操作对象的引用而不是实际的对象，为此引用类型的值是按引用访问的。

1、动态属性

两种类型的变量定义方式是类似的，但值存到变量中后，可执行的操作则大相径庭。对于引用类型的值，我们可以为其添加属性和方法，也可以改变和删除其属性和方法。如下

	var person=new Object();
    	person.name="idea";
    	alert(person.name); //"idea"


以上代码创建了一个对象，并把它保存在了变量person中，，然后我们为其添加了name属性，并进行了赋值，紧接着通过alert（）函数访问了这个属性，如果对象不被销毁或者这个属性不被删除，则这个属性将一直存在。

但是我们不能给基本类型的值添加属性，尽管这样做不会导致任何错误。

2、复制变量值

除了保存的方式不同，在从一个变量向另一个变量复制值时，两种类型也不同。
如果是基本类型，则会创建一个新值，然后把新值复制到为新变量分配的位置上。
如果是引用类型，同样也会将其存储的值复制一份到新分配的空间，不同的是，这个值的副本实际上是一个指针，而这个指针指向存储在堆中的一个对象。复制操作结束后，两个变量实际上将引用同一个对象，因此，改变其中一个量，就会影响另一个变量。
如下例：

	var obj1=new Object();
    	var obj2=obj1;
    	obj1.name="idea";
    	alert(obj2.name); //"idea"
   	
3、传递参数

ES中的所有函数的参数都是按值传递的，即把函数外部的值复制到函数内部的参数，就像把值从一个变量复制到另一个变量一样，所以，复制变量上面已经讲过，有不少人可能会困惑，访问变量有按值和按引用两种，而参数只能按值传递。下面解惑：
在传递基本类型的值时，被传递的值会被复制给一个局部变量，即命名参数。
在传递引用类型的值时，会把这个值在内存中的地址复制给一个局部变量，因此这个局部变量的变化会反映在函数的外部。

看下面的例子：

	function addTen(num){
		num+=10;
		return num;
    	}
    	var count=20;
    	var result=addTen(count);
    	alert(count);
    	alert(result);

这里的函数addTen()有一个参数num，参数实际上是函数的局部变量，在调用函数时，变量count被作为参数传递给函数，于是20被复制给参数num以便在addTen()中使用，函数内部，参数num的值被加上了10；但这一变化不会影响到外部的count变量，num和count仅仅是具有相同的值，假如num是按照引用传递的话，变量count的值也会变成30，从而反映函数内部的修改，但如果使用对象，问题就不怎么好理解了，看下面例子：

	function setName(obj){
		obj.name="idea";
    	}
    	var person=new Object();
    	setName(person);
    	alert(person.name);
   	
以上代码创建了一个对象，将其保存在了person中，然后这个变量传递到setName()之后复制给了Obj。在函数内部，obj和person引用的是同一个对象，换句话说，**即使这个变量是按值传递的，obj也会按引用来访问同一个对象，于是，函数内部为obj添加属性后，函数外部的person也会有所反应。但有不少开发人员认为：在局部作用域中修改的对象会在全局作用域中反映出来，就说明参数是按引用传递的，为了证明其是按值传递的，看下面的例子：

	function setName(obj){
		obj.name="idea";
		obj=new Object();
		obj.name="alien";
    	}
    	var person=new Object();
    	setName(person);
    	alert(person.name);//"idea"
   	
这个例子和前面那个例子唯一的区别，是在函数内添加了两行代码。
产生了什么作用呢，新建了一个对象，改变了对象的属性name的值，如果是按照引用来传递的，那么person的name属性就是alien，而不是idea。实际上，当在函数内部重写obj时，这个变量引用的就是一个局部对象了，这个局部对象会在函数执行完毕后立即销毁。

注：可以把ES中函数的参数想象为局部变量。

4、检测类型

要检测一个变量是不是基本类型，前面提到过的typeof操作符是最佳的工具，说具体点，typeof是确定一个变量是字符串、数值、布尔值，还是undefined的最佳工具，如果变量的值是对象或null，则typeof会返回“object”。

虽然typeof是个有力的工具，但是在检测引用类型时，它的用处不大，因为通常我们并不想知道某个值是对象，而是想知道它具体是什么对象，对此，ES提供了instanceof操作符。

例子如下：

	alert(person instanceof Object);	

如果变量是给定引用类型的实例，那么就会返回true，当然，如果用instanceof检测基本类型，则始终会返回false，因为基本类型不是对象。

## 执行环境和作用域

执行环境是js中最为重要的一个概念，定义了变量或函数有权访问的其他数据，决定了它们各自的行为，每个执行环境都有与之关联的变量对象，环境中定义的所有变量和函数都保存在这个对象中，我们编写代码时无法访问这个对象，但解析器在处理数据时会在后台使用它。
全局执行环境是最外围的一个执行环境，根据ES实现所在的宿主环境不同，表示执行环境的对象也不一样，在web浏览器中，全局执行环境被认为是window对象，因为所有全局变量和函数都是作为window的属性和方法创建的。某个执行环境中的所有代码执行完毕后，该环境被销毁，保存在其中的变量和函数定义也随之销毁（全局执行环境直到应用程序退出时才被销毁）。
每个函数都有自己的执行环境，当执行流进入一个函数时，函数的环境就会被推入一个环境栈中，函数执行后，栈将其函数弹出，把控制权返回给之前的执行环境。
当代码在一个环境中执行时，会创建变量对象的一个作用域链。作用域链的用途，是保证对执行环境有权访问的所有变量和函数的有序访问。作用域链的前端，始终都是当前执行的代码所在环境的变量对象。

活动对象最开始只包含一个变量，即arguments对象（这个对象在全局环境中是不存在的），。作用域链中的下一个变量对象来自包含（外部）环境，再下一个变量对象则来自下一个包含环境，这样，一直延续到全局执行环境，全局执行环境的变量对象始终都是作用域链中的最后一个对象。
标识符解析是沿着作用域链一级一级的搜索过程，搜索过程始终从链的前端开始逐级向后回溯，直至找到标识符为止，如果找不到，通常会导致错误发生。

	var color="blue";
        function changeColor(){
            if (color==="blue") {
                color="red";
            } else {
                color="blue";
            }
        }
        changeColor();
        alert("Color is now*+color");

changeColor()的作用域包含两个对象，它自己的变量对象和全局环境的变量对象，可以在函数内部访问color，就是因为可以在这个作用域链中找到它。

此外，在局部作用域中定义的变量可以在局部环境中和全局变量互换使用。内部环境可以通过作用域链访问所有外部环境，外部环境不能访问内部环境中的任何变量和函数，这些环境之间的联系是线性、有次序的。每个环境都可以向上搜索作用域链，以查询变量和函数名；但任何环境都不能通过向下搜索作用域链而进入执行环境。

1、延长作用域链

虽然执行环境的类型只有两种——全局和局部，但还有其他办法来延长作用域链，因为有些语句可以在作用域链的前端临时增加一个变量对象。该变量对象会在代码执行后被移除，有两种情况下会发生这种现象，具体来说，就是当执行流进入下列任何一个语句时，作用域链就会加长：

- try-catch语句的catch块
- with语句

这两个语句都会在作用域链的前端添加一个变量对象。

对with语句来说，会将指定的对象添加到作用域链中

对catch语句来说，会创建一个新的变量对象，其中包含的是被抛出的错误对象的声明

2、没有块级作用域

js没有块级作用域经常会导致理解上的困惑，

在其他类C语言中，用花括号包含起来的代码块都有自己的作用域，因而支持根据条件来定义变量。即在语句执行完毕后它不会被销毁，而是将变量添加到当前的执行环境中。

2.1 声明变量

使用var声明的变量会自动被添加到最接近的环境中，在函数内部，最接近的环境就是函数的局部环境；在with语句中，最接近的就是函数环境。如果初始化变量没有使用var，该变量会自动添加到全局环境。

在编写js代码的过程中，不声明而直接初始化变量是一个常见的错误做法，可能导致意外，建议一定先声明。

2.2 查询标识符

当在某个环境为了读取或者写入而引用一个标识符时，必须通过搜索来确定该标识符实际代表什么，搜索过程从作用域的前端开始，向上逐级查询，如未找到，一直搜索到全局环境，若还未找到，意味着该变量未声明。如果局部环境中存在着同名标识符，就不会使用位于父环境中的标识符。

ps：变量查询也不是没有代价的，明显，访问局部变量要比访问局部变量更快，因为不用向上搜索作用域链。但随着js引擎的逐步优化，将来这个差别可能可以忽略不计。

3、垃圾收集

js中具有自动垃圾收集机制，执行环境会负责管理代码执行过程中使用的内存，所需内存的分配和无用内存的回收完全实现了自动管理。这种机制其实也简单，找出那些不再继续使用的变量，释放其内存。为此垃圾收集器会按照固定的时间间隔周期性的执行这一操作。

先来分析一下函数中局部变量的生命周期。局部变量只在函数执行过程中存在，而在这个过程中，会为局部变量在栈或堆内存上分配相应空间，以便存储它们的值，然后在函数中使用这些值，直至函数执行结束。此时，局部变量就没有存在的必要了，因此可以释放内存供将来使用。但并非所有情况下都这么容易得出结论，垃圾收集器必须对其进行跟踪，对不再有用的变量打上标记以备将来收回它占用的内存，标识策略可能会因实现而异，但具体到浏览器实现通常有两个策略。

3.1 标记清除

是js中最常用的垃圾收集方式，当变量进入环境，就将这个变量标记为“进入环境”。逻辑上永远不能释放进入环境的变量占用的内存，因为只要执行流进入相应环境，就可能用到它们，而当变量离开环境时，将其标记“离开环境”。

可以使用任何方式来标记变量，说到底，如何标记变量不重要，关键在于采取什么策略。

垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记，然后，会去掉环境中的变量以及被环境中变量引用的变量的标记，而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了，最后，垃圾收集器完成内存清除工作，销毁那些带标记的值并回收它们所占用的内存空间。

3.2 引用计数

含义是跟踪记录每个值被引用的次数，当声明一个变量并将一个引用类型值赋给该变量时，这个值的引用次数是1，如果同一个值又被赋给另一个变量，引用次数加1，相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数减1，引用次数变成0，说明没有办法再访问这个值，因而就可以进行回收。

3.3 性能问题

垃圾收集是周期性运行的，如果为变量分配的内存数量很可观，那么回收工作量也是很大的，这个时候，确定收集的时间间隔就很重要了。

3.4 管理内存

在使用具备垃圾收集机制的语言编写程序时，开发人员一般不必操心内存管理的问题，但是js有所不同，其中最主要的问题是，分配给web浏览器的可用内存数量通常比分配给桌面应用程序的少，目的是出于安全考虑，防止运行js的网页耗尽全部系统内存而导致系统崩溃。内存限制问题不仅会影响给变量分配内存，同时还会影响调用栈以及在一个线程中能够同时执行的语句数量。

因此，确保使用最少的内存可以让页面获得更好的性能，而优化内存占用的最佳方式，就是为执行中的代码只保存必要的数据，一旦数据不再有用，最好通过将其值设置为null来释放其引用，这个做法叫解除引用。

不过解除一个值的引用并不意味着自动回收该值所占用的内存，它的真正作用是让值脱离执行环境，以便垃圾收集器下次运行时将其回收。

好了，关于“变量、作用域和内存”就先简单说到这儿了，其实也蛮多的，但是耐心的品味一下就能有不少收获。下次就该是js中的大块头之一——“引用类型”了，敬请期待~





